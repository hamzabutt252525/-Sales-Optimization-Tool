import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score
import datetime as dt
import warnings
warnings.filterwarnings('ignore')

class CustomerSegmentation:
    """
    A tool for customer segmentation using RFM (Recency, Frequency, Monetary) analysis
    and K-Means clustering to enable targeted marketing strategies.
    """
    
    def __init__(self, data_path=None):
        """
        Initialize the Customer Segmentation tool.
        
        Parameters:
        data_path (str): Path to the customer transaction data CSV file
        """
        self.data = None
        self.rfm = None
        self.rfm_scaled = None
        self.kmeans = None
        self.segments = None
        self.segment_analysis = None
        
        if data_path:
            self.load_data(data_path)
    
    def load_data(self, data_path):
        """
        Load customer transaction data from a CSV file.
        
        Expected columns: CustomerID, InvoiceDate, InvoiceNo, Quantity, UnitPrice
        """
        try:
            self.data = pd.read_csv(data_path)
            print(f"Data loaded successfully with {len(self.data)} records")
            return True
        except Exception as e:
            print(f"Error loading data: {e}")
            return False
    
    def preprocess_data(self):
        """
        Preprocess the data for RFM analysis.
        """
        # Check if data is loaded
        if self.data is None:
            print("No data loaded. Please load data first.")
            return False
        
        # Convert InvoiceDate to datetime
        self.data['InvoiceDate'] = pd.to_datetime(self.data['InvoiceDate'])
        
        # Calculate total amount for each transaction
        self.data['TotalAmount'] = self.data['Quantity'] * self.data['UnitPrice']
        
        # Remove rows with missing CustomerID
        self.data = self.data.dropna(subset=['CustomerID'])
        
        # Remove rows with negative or zero values
        self.data = self.data[(self.data['Quantity'] > 0) & (self.data['UnitPrice'] > 0)]
        
        print("Data preprocessing completed")
        return True
    
    def calculate_rfm(self, snapshot_date=None):
        """
        Calculate RFM metrics for each customer.
        
        Parameters:
        snapshot_date (datetime): Reference date for recency calculation (default: max date + 1 day)
        """
        if self.data is None:
            print("No data loaded. Please load data first.")
            return False
        
        if snapshot_date is None:
            snapshot_date = self.data['InvoiceDate'].max() + dt.timedelta(days=1)
        
        # Calculate RFM metrics
        rfm = self.data.groupby('CustomerID').agg({
            'InvoiceDate': lambda x: (snapshot_date - x.max()).days,  # Recency
            'InvoiceNo': 'count',  # Frequency
            'TotalAmount': 'sum'    # Monetary
        }).reset_index()
        
        # Rename columns
        rfm.rename(columns={
            'InvoiceDate': 'Recency',
            'InvoiceNo': 'Frequency',
            'TotalAmount': 'Monetary'
        }, inplace=True)
        
        self.rfm = rfm
        print("RFM metrics calculated successfully")
        return True
    
    def find_optimal_clusters(self, max_clusters=10):
        """
        Find the optimal number of clusters using the Elbow Method and Silhouette Score.
        
        Parameters:
        max_clusters (int): Maximum number of clusters to test
        
        Returns:
        tuple: (optimal_clusters_by_elbow, optimal_clusters_by_silhouette)
        """
        if self.rfm is None:
            print("RFM metrics not calculated. Please calculate RFM first.")
            return None, None
        
        # Prepare data for clustering
        rfm_data = self.rfm[['Recency', 'Frequency', 'Monetary']]
        
        # Standardize the data
        scaler = StandardScaler()
        rfm_scaled = scaler.fit_transform(rfm_data)
        self.rfm_scaled = rfm_scaled
        
        # Calculate inertia for different number of clusters
        inertia = []
        silhouette_scores = []
        
        for k in range(2, max_clusters + 1):
            kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
            kmeans.fit(rfm_scaled)
            inertia.append(kmeans.inertia_)
            silhouette_scores.append(silhouette_score(rfm_scaled, kmeans.labels_))
        
        # Plot Elbow Method
        plt.figure(figsize=(12, 5))
        plt.subplot(1, 2, 1)
        plt.plot(range(2, max_clusters + 1), inertia, 'bo-')
        plt.xlabel('Number of clusters')
        plt.ylabel('Inertia')
        plt.title('Elbow Method')
        
        # Plot Silhouette Score
        plt.subplot(1, 2, 2)
        plt.plot(range(2, max_clusters + 1), silhouette_scores, 'bo-')
        plt.xlabel('Number of clusters')
        plt.ylabel('Silhouette Score')
        plt.title('Silhouette Score')
        
        plt.tight_layout()
        plt.show()
        
        # Find optimal number of clusters
        # For Elbow Method, we look for the point where the rate of decrease slows down
        # This is a simplified approach - in practice, you might want a more sophisticated method
        deltas = np.diff(inertia)
        optimal_elbow = np.argmin(deltas) + 2  # +2 because we started from 2 clusters
        
        # For Silhouette Score, we look for the maximum value
        optimal_silhouette = np.argmax(silhouette_scores) + 2  # +2 because we started from 2 clusters
        
        print(f"Optimal number of clusters by Elbow Method: {optimal_elbow}")
        print(f"Optimal number of clusters by Silhouette Score: {optimal_silhouette}")
        
        return optimal_elbow, optimal_silhouette
    
    def perform_clustering(self, n_clusters=5):
        """
        Perform K-Means clustering on RFM data.
        
        Parameters:
        n_clusters (int): Number of clusters to create
        """
        if self.rfm_scaled is None:
            print("RFM data not scaled. Please run find_optimal_clusters or calculate_rfm first.")
            return False
        
        # Perform K-Means clustering
        self.kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        cluster_labels = self.kmeans.fit_predict(self.rfm_scaled)
        
        # Add cluster labels to RFM dataframe
        self.rfm['Cluster'] = cluster_labels
        
        # Create segments dataframe
        self.segments = self.rfm.copy()
        
        print(f"K-Means clustering completed with {n_clusters} clusters")
        return True
    
    def analyze_segments(self):
        """
        Analyze customer segments and provide insights.
        """
        if self.segments is None:
            print("No segments available. Please perform clustering first.")
            return False
        
        # Calculate segment statistics
        segment_analysis = self.segments.groupby('Cluster').agg({
            'CustomerID': 'count',
            'Recency': 'mean',
            'Frequency': 'mean',
            'Monetary': 'mean'
        }).reset_index()
        
        # Rename columns
        segment_analysis.rename(columns={
            'CustomerID': 'NumCustomers',
            'Recency': 'AvgRecency',
            'Frequency': 'AvgFrequency',
            'Monetary': 'AvgMonetary'
        }, inplace=True)
        
        # Calculate percentage of customers in each segment
        total_customers = segment_analysis['NumCustomers'].sum()
        segment_analysis['PctCustomers'] = segment_analysis['NumCustomers'] / total_customers * 100
        
        # Calculate percentage of total monetary value in each segment
        total_monetary = segment_analysis['AvgMonetary'].sum()
        segment_analysis['PctMonetary'] = segment_analysis['AvgMonetary'] / total_monetary * 100
        
        # Sort by monetary value
        segment_analysis = segment_analysis.sort_values('AvgMonetary', ascending=False)
        
        # Assign segment names based on characteristics
        segment_names = []
        for _, row in segment_analysis.iterrows():
            cluster = int(row['Cluster'])
            recency = row['AvgRecency']
            frequency = row['AvgFrequency']
            monetary = row['AvgMonetary']
            
            if recency < 30 and frequency > 10 and monetary > 1000:
                segment_names.append("Champions")
            elif recency < 60 and frequency > 5 and monetary > 500:
                segment_names.append("Loyal Customers")
            elif recency < 90 and frequency > 3 and monetary > 200:
                segment_names.append("Potential Loyalists")
            elif recency < 30 and frequency < 3 and monetary < 200:
                segment_names.append("New Customers")
            elif recency > 90 and frequency > 5 and monetary > 500:
                segment_names.append("At Risk")
            elif recency > 180 and frequency < 2 and monetary < 100:
                segment_names.append("Lost")
            elif frequency > 5 and monetary > 300:
                segment_names.append("Need Attention")
            else:
                segment_names.append(f"Segment {cluster}")
        
        segment_analysis['SegmentName'] = segment_names
        
        self.segment_analysis = segment_analysis
        print("Segment analysis completed")
        return True
    
    def visualize_segments(self):
        """
        Visualize customer segments.
        """
        if self.segment_analysis is None:
            print("No segment analysis available. Please run analyze_segments first.")
            return False
        
        # Create a figure with multiple subplots
        plt.figure(figsize=(16, 12))
        
        # Plot 1: Customer distribution across segments
        plt.subplot(2, 2, 1)
        colors = plt.cm.tab10(np.linspace(0, 1, len(self.segment_analysis)))
        plt.pie(self.segment_analysis['PctCustomers'], labels=self.segment_analysis['SegmentName'], 
                autopct='%1.1f%%', colors=colors, startangle=90)
        plt.title('Customer Distribution Across Segments')
        
        # Plot 2: Monetary value distribution across segments
        plt.subplot(2, 2, 2)
        plt.pie(self.segment_analysis['PctMonetary'], labels=self.segment_analysis['SegmentName'], 
                autopct='%1.1f%%', colors=colors, startangle=90)
        plt.title('Monetary Value Distribution Across Segments')
        
        # Plot 3: RFM scatter plot
        plt.subplot(2, 2, 3)
        scatter = plt.scatter(
            self.segments['Recency'], 
            self.segments['Frequency'], 
            c=self.segments['Cluster'], 
            cmap='viridis', 
            alpha=0.6,
            s=self.segments['Monetary']/10
        )
        plt.colorbar(scatter, label='Cluster')
        plt.xlabel('Recency (days)')
        plt.ylabel('Frequency')
        plt.title('RFM Scatter Plot (Bubble size = Monetary)')
        
        # Plot 4: Segment characteristics
        plt.subplot(2, 2, 4)
        x = np.arange(len(self.segment_analysis))
        width = 0.25
        
        plt.bar(x - width, self.segment_analysis['AvgRecency'], width, label='Recency')
        plt.bar(x, self.segment_analysis['AvgFrequency'], width, label='Frequency')
        plt.bar(x + width, self.segment_analysis['AvgMonetary']/10, width, label='Monetary/10')
        
        plt.xticks(x, self.segment_analysis['SegmentName'], rotation=45, ha='right')
        plt.ylabel('Value')
        plt.title('Segment Characteristics')
        plt.legend()
        
        plt.tight_layout()
        plt.show()
    
    def generate_recommendations(self):
        """
        Generate marketing recommendations for each customer segment.
        """
        if self.segment_analysis is None:
            print("No segment analysis available. Please run analyze_segments first.")
            return None
        
        recommendations = []
        
        for _, row in self.segment_analysis.iterrows():
            segment_name = row['SegmentName']
            pct_customers = row['PctCustomers']
            avg_recency = row['AvgRecency']
            avg_frequency = row['AvgFrequency']
            avg_monetary = row['AvgMonetary']
            
            if segment_name == "Champions":
                rec = "Offer exclusive deals and early access to new products. Implement a loyalty program with premium benefits."
                priority = "High"
                expected_impact = "15-20% increase in repeat purchases"
            elif segment_name == "Loyal Customers":
                rec = "Provide personalized recommendations based on purchase history. Offer loyalty points and special discounts."
                priority = "High"
                expected_impact = "10-15% increase in customer lifetime value"
            elif segment_name == "Potential Loyalists":
                rec = "Engage with personalized content and offers. Encourage reviews and social media engagement."
                priority = "Medium"
                expected_impact = "8-12% increase in purchase frequency"
            elif segment_name == "New Customers":
                rec = "Welcome them with a special offer. Provide onboarding support and educational content about products."
                priority = "Medium"
                expected_impact = "15-25% increase in conversion to repeat customers"
            elif segment_name == "At Risk":
                rec = "Send personalized win-back campaigns with special offers. Ask for feedback to understand declining engagement."
                priority = "High"
                expected_impact = "10-15% reduction in churn rate"
            elif segment_name == "Lost":
                rec = "Reconnect with aggressive offers or new product announcements. Survey to understand reasons for leaving."
                priority = "Low"
                expected_impact = "5-10% reactivation rate"
            elif segment_name == "Need Attention":
                rec = "Create targeted campaigns to increase purchase frequency. Cross-sell related products."
                priority = "Medium"
                expected_impact = "8-12% increase in purchase frequency"
            else:
                rec = "Analyze further to understand segment characteristics and develop targeted strategies."
                priority = "Medium"
                expected_impact = "To be determined"
            
            recommendations.append({
                'Segment': segment_name,
                'PctCustomers': pct_customers,
                'AvgRecency': avg_recency,
                'AvgFrequency': avg_frequency,
                'AvgMonetary': avg_monetary,
                'Recommendation': rec,
                'Priority': priority,
                'ExpectedImpact': expected_impact
            })
        
        recommendations_df = pd.DataFrame(recommendations)
        return recommendations_df
    
    def export_for_tableau(self, file_path='customer_segments_for_tableau.csv'):
        """
        Export the segmented data for visualization in Tableau.
        
        Parameters:
        file_path (str): Path to save the CSV file
        """
        if self.segments is None:
            print("No segments available. Please perform clustering first.")
            return False
        
        # Merge with segment names
        segments_with_names = self.segments.merge(
            self.segment_analysis[['Cluster', 'SegmentName']], 
            on='Cluster', 
            how='left'
        )
        
        # Export to CSV
        segments_with_names.to_csv(file_path, index=False)
        print(f"Data exported to {file_path} for Tableau visualization")
        return True
    
    def run_full_analysis(self, data_path, n_clusters=5, snapshot_date=None):
        """
        Run the complete customer segmentation analysis.
        
        Parameters:
        data_path (str): Path to the customer transaction data CSV file
        n_clusters (int): Number of clusters to create
        snapshot_date (datetime): Reference date for recency calculation
        
        Returns:
        DataFrame: Marketing recommendations for each segment
        """
        print("Starting Customer Segmentation Analysis")
        print("=" * 50)
        
        # Load and preprocess data
        self.load_data(data_path)
        self.preprocess_data()
        
        # Calculate RFM metrics
        self.calculate_rfm(snapshot_date)
        
        # Find optimal number of clusters
        print("\nFinding optimal number of clusters...")
        optimal_elbow, optimal_silhouette = self.find_optimal_clusters()
        
        # Use the provided number of clusters or the optimal one
        if n_clusters is None:
            n_clusters = optimal_silhouette
            print(f"Using optimal number of clusters: {n_clusters}")
        else:
            print(f"Using specified number of clusters: {n_clusters}")
        
        # Perform clustering
        self.perform_clustering(n_clusters)
        
        # Analyze segments
        self.analyze_segments()
        
        # Visualize segments
        self.visualize_segments()
        
        # Generate recommendations
        recommendations = self.generate_recommendations()
        
        # Export for Tableau
        self.export_for_tableau()
        
        print("\nCustomer Segmentation Analysis Complete")
        print("=" * 50)
        
        return recommendations


# Example usage
if __name__ == "__main__":
    # Create an instance of the CustomerSegmentation tool
    segmentation_tool = CustomerSegmentation()
    
    # Run the full analysis (replace with your actual data path)
    # For demonstration, we'll create a sample dataset
    import random
    from datetime import datetime, timedelta
    
    # Create sample data
    def create_sample_data(num_customers=1000, num_transactions=5000):
        customers = [f"C{str(i).zfill(5)}" for i in range(1, num_customers + 1)]
        
        data = []
        for _ in range(num_transactions):
            customer_id = random.choice(customers)
            invoice_date = datetime.now() - timedelta(days=random.randint(1, 365))
            invoice_no = f"I{random.randint(10000, 99999)}"
            quantity = random.randint(1, 10)
            unit_price = round(random.uniform(10, 100), 2)
            
            data.append({
                'CustomerID': customer_id,
                'InvoiceDate': invoice_date,
                'InvoiceNo': invoice_no,
                'Quantity': quantity,
                'UnitPrice': unit_price
            })
        
        return pd.DataFrame(data)
    
    # Create and save sample data
    sample_data = create_sample_data()
    sample_data.to_csv('sample_customer_data.csv', index=False)
    
    # Run the analysis
    recommendations = segmentation_tool.run_full_analysis('sample_customer_data.csv', n_clusters=5)
    
    # Display recommendations
    print("\nMarketing Recommendations:")
    print("=" * 50)
    for _, rec in recommendations.iterrows():
        print(f"\nSegment: {rec['Segment']} ({rec['PctCustomers']:.1f}% of customers)")
        print(f"Recommendation: {rec['Recommendation']}")
        print(f"Priority: {rec['Priority']}")
        print(f"Expected Impact: {rec['ExpectedImpact']}")
